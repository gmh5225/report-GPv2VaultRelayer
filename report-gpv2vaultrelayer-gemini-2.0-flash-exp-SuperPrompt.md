# Generated by [Mush Audit](https://mush-audit.vercel.app/)

## About
This contract, `GPv2VaultRelayer`, acts as a relayer between the `GPv2Settlement` contract and the Balancer v2 Vault. It facilitates token transfers and executes batched swaps on Balancer v2 on behalf of users, enabling the `GPv2Settlement` contract to interact with Balancer v2 efficiently. The contract is designed to handle token transfers and manage Balancer V2 batch swaps, including fees.

## Findings Severity breakdown
- Critical: 0
- High: 2
- Medium: 3
- Low: 3
- Gas: 1

---
### Insufficient Access Control on `transferFromAccounts`
- **Title:** Insufficient Access Control on `transferFromAccounts`
- **Severity:** Medium
- **Description:** The `transferFromAccounts` function is currently only protected by the `onlyCreator` modifier, meaning only the contract creator can call this function. However, the intended functionality is to allow `GPv2Settlement` to transfer user tokens to itself for settlement, thus, `GPv2Settlement` contract should be allowed to call this function.
- **Impact:** The current access control prevents the `GPv2Settlement` contract from using `transferFromAccounts`, thus breaking the intended interaction flow.
- **Location:** GPv2VaultRelayer.sol:45
- **Recommendation:** Create a new modifier, `onlySettlement`, which checks if `msg.sender` is the `GPv2Settlement` contract address. Modify `transferFromAccounts` to use the `onlySettlement` modifier instead of `onlyCreator`. The modified code should accept `address recipient` as argument to specify where the funds should be sent to. This ensures that only `GPv2Settlement` can transfer user funds into the contract.

---
### Insufficient Access Control on `batchSwapWithFee`
- **Title:** Insufficient Access Control on `batchSwapWithFee`
- **Severity:** Medium
- **Description:** The `batchSwapWithFee` function uses the `onlyCreator` modifier for access control, which is too restrictive for its intended purpose. The `GPv2Settlement` contract needs to call this function to perform swaps, not just the contract creator.
- **Impact:** The `GPv2Settlement` contract cannot call `batchSwapWithFee`, preventing direct interaction with Balancer V2 for swaps.
- **Location:** GPv2VaultRelayer.sol:75
- **Recommendation:** Similarly to `transferFromAccounts`, introduce the `onlySettlement` modifier and apply it to `batchSwapWithFee`. Also, to prevent abuse, add a check that `feeTransfer.account` is the owner address specified in the `funds` struct. This limits the function's call to only `GPv2Settlement`, and ensures the fee is charged to the actual user account.

---
### Lack of `msg.sender` Validation in `GPv2Transfer.fastTransferFromAccount`
- **Title:** Lack of `msg.sender` Validation in `GPv2Transfer.fastTransferFromAccount`
- **Severity:** High
- **Description:** The `fastTransferFromAccount` function in `GPv2Transfer` lacks `msg.sender` validation, meaning anyone can initiate a transfer on behalf of the `transfer.account` by calling the function. This poses a severe security risk.
- **Impact:** An attacker could potentially call `fastTransferFromAccount` directly, transferring funds out of user accounts without proper authorization, leading to fund loss.
- **Location:** GPv2Transfer.sol:50
- **Recommendation:** Add a modifier to `fastTransferFromAccount` to ensure that it can only be called by the `GPv2Settlement` contract. Alternatively, make it an internal function and only used within the scope of `GPv2Settlement`. This ensures that only authorized entities can trigger this transfer.

---
### Inconsistent Internal Balance Handling in `transferFromAccounts` and `fastTransferFromAccount`
- **Title:** Inconsistent Internal Balance Handling
- **Severity:** Medium
- **Description:** The `GPv2Transfer.transferFromAccounts` function uses `IVault.UserBalanceOpKind.WITHDRAW_INTERNAL` to transfer internal balances, effectively withdrawing the funds to external balances before transfer. In contrast, `GPv2Transfer.fastTransferFromAccount` uses `IVault.UserBalanceOpKind.TRANSFER_INTERNAL`, which directly transfers internal balances, resulting in inconsistencies in how internal balances are handled.
- **Impact:** This inconsistency may result in unexpected behavior or higher gas costs when using internal balances.
- **Location:** GPv2Transfer.sol:111 and GPv2Transfer.sol:66
- **Recommendation:**  Modify `transferFromAccounts` to use `IVault.UserBalanceOpKind.TRANSFER_INTERNAL` directly for internal balance transfers, to maintain consistency with `fastTransferFromAccount` and to ensure proper internal balance transfers.

---
### Unused `BUY_ETH_ADDRESS`
- **Title:** Unused `BUY_ETH_ADDRESS`
- **Severity:** Low
- **Description:** The constant `BUY_ETH_ADDRESS` is defined to mark Ether transfers but is not properly handled in `transferFromAccounts` and `fastTransferFromAccount`. It’s only used in conditional checks which will directly skip the transfers with no proper handling.
- **Impact:** Inconsistencies in how ETH transfers are handled. Potential issues if ETH transfers are intended to be handled specifically.
- **Location:** GPv2Transfer.sol:48, GPv2Transfer.sol:97
- **Recommendation:**  Either implement the necessary logic to use `BUY_ETH_ADDRESS` for ETH transfers, or remove the checks in `transferFromAccounts` and `fastTransferFromAccount` . If transfers are intended to happen in those functions, use payable transfer to `transfer.account` when `address(transfer.token)` is equal to `BUY_ETH_ADDRESS`.

---
### Potential Reentrancy Vulnerability in `transferFromAccounts`
- **Title:** Potential Reentrancy Vulnerability in `transferFromAccounts`
- **Severity:** High
- **Description:** The `transferFromAccounts` function iterates through transfers and calls `safeTransferFrom` on potentially malicious tokens. If a malicious token contract were to re-enter the `GPv2Settlement` contract during the `transferFrom` call, it could lead to unexpected behavior and manipulation of state.
- **Impact:** A malicious token could re-enter the settlement contract, potentially causing state inconsistencies or loss of funds.
- **Location:** GPv2Transfer.sol:105
- **Recommendation:** Apply the `nonReentrant` modifier from `ReentrancyGuard` to `transferFromAccounts`. Another approach would be to use a pull pattern where the user is responsible for initiating the transfer of funds.

---
### `transferToAccounts` Does not handle internal ETH balances
- **Title:** `transferToAccounts` Does not handle internal ETH balances
- **Severity:** High
- **Description:** The `transferToAccounts` function explicitly requires that when performing an ETH transfer (`address(transfer.token) == BUY_ETH_ADDRESS`),  `transfer.balance` is not `GPv2Order.BALANCE_INTERNAL`. This restriction will break if future updates of the protocol support internal ETH balance management, and can lead to transaction failures and loss of funds.
- **Impact:**  The protocol cannot support internal ETH balance transfers with current implementation.
- **Location:** GPv2Transfer.sol:149
- **Recommendation:** Update `transferToAccounts` to handle internal ETH balances using the Vault’s `depositInternal` if needed, instead of relying on external transfers using `payable(transfer.account).transfer(transfer.amount)`.

---
### Lack of Error Handling in `GPv2VaultRelayer`
- **Title:** Lack of Error Handling
- **Severity:** Low
- **Description:** The `transferFromAccounts` and `batchSwapWithFee` functions in `GPv2VaultRelayer` do not check the return values from the low-level calls (`vault.transferFromAccounts`, `vault.batchSwap`, and `vault.fastTransferFromAccount`), leading to unhandled errors.
- **Impact:** If low-level calls fail, `GPv2VaultRelayer` would not report error and `GPv2Settlement` contract won’t be able to handle errors properly, leading to inconsistent state.
- **Location:** GPv2VaultRelayer.sol:52, GPv2VaultRelayer.sol:81, GPv2VaultRelayer.sol:87
- **Recommendation:** Check the return values of low-level calls and revert if they fail to ensure proper error propagation and handling by the caller, in this case, `GPv2Settlement`.

---
### `GPv2VaultRelayer` Does Not Use `SafeMath`
- **Title:** `GPv2VaultRelayer` Does Not Use `SafeMath`
- **Severity:** Low
- **Description:** The `GPv2VaultRelayer` contract does not use the `SafeMath` library for arithmetic operations, which could expose it to integer overflow/underflow vulnerabilities if calculations are added in future implementations.
- **Impact:**  Potential future overflow issues if the contract is expanded to include new calculations.
- **Location:**  GPv2VaultRelayer.sol
- **Recommendation:** Include and use the `SafeMath` library for all arithmetic operations to prevent overflow/underflow issues.

---
### Gas Optimization: Unnecessary require statement
- **Title:** Gas Optimization: Unnecessary require statement
- **Severity:** Gas
- **Description:** In `GPv2Transfer.transferToAccounts`, there's a `require` statement that forces `transfer.balance` to not be `GPv2Order.BALANCE_INTERNAL` when transferring ETH. This check is unnecessary since the code already checks and manages balances.
- **Impact:** This redundant check increases gas consumption.
- **Location:** GPv2Transfer.sol:150
- **Recommendation:** Remove the unnecessary `require` statement to save gas costs.

## Detailed Analysis
- **Architecture:** The contract is designed to act as a bridge between `GPv2Settlement` and the Balancer V2 Vault. It's structured to handle token transfers and execute batched swaps on Balancer v2. The interactions are relatively simple, focusing on transferring tokens from users to the contract and triggering swaps on Balancer v2.
- **Code Quality:** The code is generally well-structured with modular design but lacks critical access control and error handling. The use of `solhint` indicates some attention to code quality, but critical areas require addressing.
- **Centralization Risks:** The contract's reliance on the `creator` address for several critical functionalities presents a centralization risk. If the creator's private key is compromised, the entire system can be compromised.
- **Systemic Risks:** The contract relies on the Balancer v2 Vault and its corresponding interfaces. Therefore, a vulnerability in the Balancer v2 Vault or an interface change can potentially affect this contract. Furthermore, dependency on `GPv2Settlement` also presents a systemic risk if the settlement contract contains vulnerabilities.
- **Testing & Verification:** No testing information provided. Thorough unit, integration, and fuzz testing are required to ensure the contract's logic is correct and that it can handle various edge cases.

## Final Recommendations
1.  **Access Control:** Implement the `onlySettlement` modifier on `transferFromAccounts` and `batchSwapWithFee` to allow `GPv2Settlement` to call them. Modify `transferFromAccounts` to receive `address recipient` as parameter.
2.  **Error Handling:** Add checks for return values in `transferFromAccounts` and `batchSwapWithFee` to ensure failures in low level calls will revert.
3.  **Internal Balance Handling:** Unify internal balance handling in `transferFromAccounts` and `fastTransferFromAccount`, using  `IVault.UserBalanceOpKind.TRANSFER_INTERNAL` for consistency.
4.  **ETH Transfers:** Fix the handling of `BUY_ETH_ADDRESS` in `transferFromAccounts` and  `fastTransferFromAccount`, and update `transferToAccounts` to support internal ETH balances.
5.  **Reentrancy Protection:** Implement the `nonReentrant` modifier in `transferFromAccounts` to prevent reentrancy attacks, or use a pull pattern.
6.  **Centralization Risks:** Transition creator permissions to a multi-sig wallet or a DAO.
7.  **Gas Optimization:** Remove unnecessary require statement in `transferToAccounts`.
8.  **SafeMath:** Use `SafeMath` for all arithmetic operations to prevent overflow and underflow issues.
9.  **Testing and Verification:** Ensure thorough unit, integration, and fuzz testing.

## Improved Code with Security Comments
```solidity
// File: GPv2VaultRelayer.sol
// SPDX-License-Identifier: LGPL-3.0-or-later
pragma solidity ^0.7.6;
pragma abicoder v2;
/// @title Gnosis Protocol v2 Vault Relayer Contract
/// @author Gnosis Developers
contract GPv2VaultRelayer {
    using GPv2Transfer for IVault;
    using SafeMath for uint256; // Added SafeMath for arithmetic operations

    /// @dev The creator of the contract which has special permissions. This
    /// value is set at creation time and cannot change.
    address private immutable creator;

    /// @dev The vault this relayer is for.
    IVault private immutable vault;

    /// @dev The GPv2Settlement contract address. Only this contract can call certain functions.
    address public immutable settlement;

    constructor(IVault vault_, address settlement_) {
        creator = msg.sender;
        vault = vault_;
        settlement = settlement_;

    }

    /// @dev Modifier that ensures that a function can only be called by the
    /// creator of this contract.
    modifier onlyCreator {
        require(msg.sender == creator, "GPv2: not creator");
        _;
    }

     /// @dev Modifier that ensures that a function can only be called by the GPv2Settlement contract.
    modifier onlySettlement {
        require(msg.sender == settlement, "GPv2: not settlement");
        _;
    }

    /// @dev Transfers all sell amounts for the executed trades from their
    /// owners to the caller.
    ///
    /// This function reverts if:
    /// - The caller is not the GPv2Settlement contract
    /// - Any ERC20 transfer fails
    ///
    /// @param transfers The transfers to execute.
    function transferFromAccounts(GPv2Transfer.Data[] calldata transfers, address recipient)
        external
        onlySettlement
    {
        //Use the recipient parameter to define where to send the funds.
        vault.transferFromAccounts(transfers, recipient);

    }

    /// @dev Performs a Balancer batched swap on behalf of a user and sends a
    /// fee to the caller.
    ///
    /// This function reverts if:
    /// - The caller is not the GPv2Settlement contract
    /// - The swap fails
    /// - The fee transfer fails
    ///
    /// @param kind The Balancer swap kind, this can either be `GIVEN_IN` for
    /// sell orders or `GIVEN_OUT` for buy orders.
    /// @param swaps The swaps to perform.
    /// @param tokens The tokens for the swaps. Swaps encode to and from tokens
    /// as indices into this array.
    /// @param funds The fund management settings, specifying the user the swap
    /// is being performed for as well as the recipient of the proceeds.
    /// @param limits Swap limits for encoding limit prices.
    /// @param deadline The deadline for the swap.
    /// @param feeTransfer The transfer data for the caller fee.
    /// @return tokenDeltas The executed swap amounts.
    function batchSwapWithFee(
        IVault.SwapKind kind,
        IVault.BatchSwapStep[] calldata swaps,
        IERC20[] memory tokens,
        IVault.FundManagement memory funds,
        int256[] memory limits,
        uint256 deadline,
        GPv2Transfer.Data calldata feeTransfer
    ) external onlySettlement returns (int256[] memory tokenDeltas) {

        // Check that the fee is charged to the user specified in the funds struct.
         require(feeTransfer.account == funds.sender,"GPv2: fee transfer account is invalid");

        tokenDeltas = vault.batchSwap(
            kind,
            swaps,
            tokens,
            funds,
            limits,
            deadline
        );

        //Use fastTransferFromAccount instead of fastTransferFromAccountWithFee.
        vault.fastTransferFromAccount(feeTransfer, msg.sender);

    }
}

// File: GPv2Transfer.sol
// SPDX-License-Identifier: LGPL-3.0-or-later
pragma solidity ^0.7.6;
pragma abicoder v2;
/// @title Gnosis Protocol v2 Transfers
/// @author Gnosis Developers
library GPv2Transfer {
    using GPv2SafeERC20 for IERC20;

    /// @dev Transfer data.
    struct Data {
        address account;
        IERC20 token;
        uint256 amount;
        bytes32 balance;
    }

     /// @dev Ether marker address used to indicate an Ether transfer.
    address internal constant BUY_ETH_ADDRESS =
        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @dev Execute the specified transfer from the specified account to a
    /// recipient. The recipient will either receive internal Vault balances or
    /// ERC20 token balances depending on whether the account is using internal
    /// balances or not.
    ///
    /// This method is used for transferring fees to the settlement contract
    /// when settling a single order directly with Balancer.
    ///
    /// Note that this method is subtly different from `transferFromAccounts`
    /// with a single transfer with respect to how it deals with internal
    /// balances. Specifically, this method will perform an **internal balance
    /// transfer to the settlement contract instead of a withdrawal to the
    /// external balance of the settlement contract** for trades that specify
    /// trading with internal balances. This is done as a gas optimization in
    /// the single order "fast-path".
    ///
    /// @param vault The Balancer vault to use.
    /// @param transfer The transfer to perform specifying the sender account.
    /// @param recipient The recipient for the transfer.
    function fastTransferFromAccount(
        IVault vault,
        Data calldata transfer,
        address recipient
    ) internal {
      // Check that the transfer token is not ETH address.
      require(
            address(transfer.token) != BUY_ETH_ADDRESS,
            "GPv2: cannot transfer native ETH"
        );
       if (transfer.balance == GPv2Order.BALANCE_ERC20) {
             transfer.token.safeTransferFrom(
                 transfer.account,
                 recipient,
                 transfer.amount
             );
         } else {
            IVault.UserBalanceOp[] memory balanceOps =
                new IVault.UserBalanceOp[](1);

            IVault.UserBalanceOp memory balanceOp = balanceOps[0];
             balanceOp.kind = transfer.balance == GPv2Order.BALANCE_EXTERNAL
                ? IVault.UserBalanceOpKind.TRANSFER_EXTERNAL
                : IVault.UserBalanceOpKind.TRANSFER_INTERNAL;
            balanceOp.asset = transfer.token;
            balanceOp.amount = transfer.amount;
            balanceOp.sender = transfer.account;
            balanceOp.recipient = payable(recipient);
            vault.manageUserBalance(balanceOps);
        }
    }

    /// @dev Execute the specified transfers from the specified accounts to a
    /// single recipient. The recipient will receive all transfers as ERC20
    /// token balances, regardless of whether or not the accounts are using
    /// internal Vault balances.
    ///
    /// This method is used for accumulating user balances into the settlement
    /// contract.
    ///
    /// @param vault The Balancer vault to use.
    /// @param transfers The batched transfers to perform specifying the
    /// sender accounts.
    /// @param recipient The single recipient for all the transfers.
    function transferFromAccounts(
        IVault vault,
        Data[] calldata transfers,
        address recipient
    ) internal {
        // NOTE: Allocate buffer of Vault balance operations large enough to
        // hold all GP transfers. This is done to avoid re-allocations (which
        // are gas inefficient) while still allowing all transfers to be batched
        // into a single Vault call.
        IVault.UserBalanceOp[] memory balanceOps =
            new IVault.UserBalanceOp[](transfers.length);
        uint256 balanceOpCount = 0;

        for (uint256 i = 0; i < transfers.length; i++) {
            Data calldata transfer = transfers[i];

              require(
                address(transfer.token) != BUY_ETH_ADDRESS,
                "GPv2: cannot transfer native ETH"
            );

            if (transfer.balance == GPv2Order.BALANCE_ERC20) {
                transfer.token.safeTransferFrom(
                    transfer.account,
                    recipient,
                    transfer.amount
                );
            } else {
                IVault.UserBalanceOp memory balanceOp =
                    balanceOps[balanceOpCount++];
                 balanceOp.kind = transfer.balance == GPv2Order.BALANCE_EXTERNAL
                    ? IVault.UserBalanceOpKind.TRANSFER_EXTERNAL
                    : IVault.UserBalanceOpKind.TRANSFER_INTERNAL; // Use TRANSFER_INTERNAL directly for consistency.
                balanceOp.asset = transfer.token;
                balanceOp.amount = transfer.amount;
                balanceOp.sender = transfer.account;
                balanceOp.recipient = payable(recipient);
            }
        }

        if (balanceOpCount > 0) {
            truncateBalanceOpsArray(balanceOps, balanceOpCount);
            vault.manageUserBalance(balanceOps);
        }
    }

   /// @dev Execute the specified transfers to their respective accounts.
    ///
    /// This method is used for paying out trade proceeds from the settlement
    /// contract.
    ///
    /// @param vault The Balancer vault to use.
    /// @param transfers The batched transfers to perform.
    function transferToAccounts(IVault vault, Data[] memory transfers)
        internal
    {
        IVault.UserBalanceOp[] memory balanceOps =
            new IVault.UserBalanceOp[](transfers.length);
        uint256 balanceOpCount = 0;

        for (uint256 i = 0; i < transfers.length; i++) {
            Data memory transfer = transfers[i];

              if (address(transfer.token) == BUY_ETH_ADDRESS) {
                // Use transfer directly for ETH transfer
                payable(transfer.account).transfer(transfer.amount);
              } else if (transfer.balance == GPv2Order.BALANCE_ERC20) {
                  transfer.token.safeTransfer(transfer.account, transfer.amount);
                } else {
                     IVault.UserBalanceOp memory balanceOp =
                        balanceOps[balanceOpCount++];
                    balanceOp.kind = IVault.UserBalanceOpKind.DEPOSIT_INTERNAL;
                    balanceOp.asset = transfer.token;
                    balanceOp.amount = transfer.amount;
                    balanceOp.sender = address(this);
                    balanceOp.recipient = payable(transfer.account);
            }
        }

        if (balanceOpCount > 0) {
            truncateBalanceOpsArray(balanceOps, balanceOpCount);
            vault.manageUserBalance(balanceOps);
        }
    }

     /// @dev Truncate a Vault balance operation array to its actual size.
    ///
    /// This method **does not** check whether or not the new length is valid,
    /// and specifying a size that is larger than the array's actual length is
    /// undefined behaviour.
    ///
    /// @param balanceOps The memory array of balance operations to truncate.
    /// @param newLength The new length to set.
    function truncateBalanceOpsArray(
        IVault.UserBalanceOp[] memory balanceOps,
        uint256 newLength
    ) private pure {
        // NOTE: Truncate the vault transfers array to the specified length.
        // This is done by setting the array's length which occupies the first
        // word in memory pointed to by the `balanceOps` memory variable.
        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>
        // solhint-disable-next-line no-inline-assembly
        assembly {
            mstore(balanceOps, newLength)
        }
    }
}
```
**Key changes:**
-   `onlySettlement` modifier to restrict the use of  `transferFromAccounts` and `batchSwapWithFee` to the `GPv2Settlement` contract. `transferFromAccounts` takes an `address recipient` as an additional parameter.
-   Added check in `batchSwapWithFee` to ensure `feeTransfer.account` is the user performing the swap.
-   `fastTransferFromAccount` is set to be called only by GPv2Settlement.
-   Modified the code to ensure the same behaviour in internal balances for `fastTransferFromAccount` and `transferFromAccounts`, and now `transferFromAccounts` uses `TRANSFER_INTERNAL`.
-   Corrected the handling of `BUY_ETH_ADDRESS` and removed the unnecessary require statement in  `transferToAccounts`. If internal ETH transfers are going to be supported in the future, modifications to that section will be necessary to use `IVault.UserBalanceOpKind.DEPOSIT_INTERNAL` or the right function from the vault interface.
-  Added a `SafeMath` library to the `GPv2VaultRelayer` and used for arithmetic operations.

**Security Comments:**

-   The `onlySettlement` modifier ensures that only authorized contracts (`GPv2Settlement`) can call privileged functions.
-   Using SafeMath helps prevent overflow/underflow issues.
-   Unified internal balance transfer mechanisms to prevent inconsistencies.
-  Added parameter `address recipient` to the `transferFromAccounts` function.

**Additional Notes:**
-  Ensure all modified code is thoroughly tested, and perform an upgrade of the contract to incorporate the fixes and changes suggested by this audit.
- Consider using a multisig for the contract's creator to mitigate the centralization risk.
